require('buffer')

/* 
Buffer - используется для работы с сырыми данными (байтами)
Static:
Buffer.alloc(size[, fill[, encoding]])
Выделяет новый буфер указаного size(0<=size<require('buffer').kMaxLength)
fill-опциональный параметр - чем заполнить буфер (<string> | <Buffer> | <Uint8Array> | <integer>)
ecnoding-только если указан fill и он string-заполняет созданый буфер fill строкой в encoding кодировки, если fill && !string - ничего не делает
================================================================================================================================================================
Buffer.allocUnsafe(size)
+скорость -секьюрность
Выделяет новый буфер указаного size с неизвестным содержимым из памяти(потенциально опасно так как в памяти может быть все что угодно)
Идеальный вариант если делать копию
const oldBuffer = Buffer.from('some data')
const bufferCopy = Buffer.allocUnsafe(oldBuffer.length)
oldBuffer.copy(bufferCopy)
================================================================================================================================================================
Buffer.allocUnsafeSlow(size)
??????????????????????????/
================================================================================================================================================================
Buffer.byteLength(string[, encoding]) : integer
string - <string> | <Buffer> | <TypedArray> | <DataView> | <ArrayBuffer> | <SharedArrayBuffer>
Возвращает числов байтов небходимое для string в указаной encoding
================================================================================================================================================================
Buffer.compare(buf1, buf2) : 0|-1|1
buf - <Buffer> | <Uint8Array>
Buffer.compare сравнивает побайтово,0-одинаковые,1-первый болььше,-1-второй больше
================================================================================================================================================================
Buffer.concat(list[, totalLength]) : Buffer
Возвращает новый буфер склееный из массива list [Buffer|Uint8Array]
totalLength-можно указать размер получившегося буфера, если > чем результат дописывается нулями
================================================================================================================================================================
Buffer.isBuffer(obj) - Array.isArray(arr) : Boolean
================================================================================================================================================================
Buffer.isEncoding(encoding) : boolean
encoding - string 
поддерживаемая ли кодировка
================================================================================================================================================================
Buffer.from(array|arrayBuffer|buffer|object|string)
================================================================================================================================================================
Buffer.from(array)
Возвращает buffer на основании масива битов в диапазоне 0-255
либо номер юникода в 16ричном формате 0x5c,0x53
либо номер в ascii таблице 32-126
================================================================================================================================================================
Instance Methods:
buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])
target:<Buffer> | <Uint8Array>
ends:not inclusive
================================================================================================================================================================
buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])
================================================================================================================================================================
buf.entries() : iterator
Итератор вида [index,byte]
================================================================================================================================================================
buf.equals(otherBuffer):boolean
сравнение буферов
================================================================================================================================================================
buf.fill(value[, offset[, end]][, encoding]):buf
value <string> | <Buffer> | <Uint8Array> | <integer>
заполняет буфер указаным value
encoding : кодировка в строковом виде, только если value = string
аналог array.fill(), но с возможностью указывать диапазон где будет заполнение
================================================================================================================================================================
buf.includes(value[, byteOffset][, encoding]): boolean
value <string> | <Buffer> | <Uint8Array> | <integer> 
encoding : кодировка в строковом виде, только если value = string
byteOffset:отступ
Есть ли value в buf
================================================================================================================================================================
buf.indexOf(value[, byteOffset][, encoding]) : integer
value <string> | <Buffer> | <Uint8Array> | <integer> 
Индекс первого вхождения value в buf
================================================================================================================================================================
buf.keys():iterator
возвращает итератор с индексами????
================================================================================================================================================================
buf.lastIndexOf(value[, byteOffset][, encoding])
================================================================================================================================================================
buf.write(string[, offset[, length]][, encoding]):integer
записывает в буфер string в кодировке encoding,
с помощью offset можно указать сдвиг от начала
length:максимальное количество байт для записи от offset
================================================================================================================================================================
buf.slice([start[, end]])|buf.subarray([start[, end]])
Возвращает буфер который ссылается на ту же память что и источник
Изменения в одном затронут изменения в другом
Грубо говоря частичная копия буфера в нужном отрезке по ссылке
================================================================================================================================================================
buf.values():iterator
возвращает значения буфера в беззнаковом виде
================================================================================================================================================================

================================================================================================================================================================

================================================================================================================================================================
8Uint = 0-255 
8Int = -128 - 127 
16Uint = 65536
16Int = -32768 - 32767
32Uint = 0 - 4294967295
32Int = -2147483648 2147483647
64Uint = 0 - (2^64)-1
64Int = -9,223,372,036,854,775,808 - 9,223,372,036,854,775,807
================================================================================================================================================================
*/
// const a = Buffer.from([0x61,97,125,0x6f,32,127,72,127,])
// console.log(a)
// console.log(a.toString())
//
// const asciiBuf = Buffer.alloc(5, 'a', 'ascii')
// console.log(asciiBuf)
// const b = Buffer.alloc(5, 'a','utf8')
// console.log(b)

// const buf = Buffer.from('hello world', 'utf8')

// console.log(buf.toString('hex'))
// // Prints: 68656c6c6f20776f726c64
// console.log(buf.toString('base64'))
// // Prints: aGVsbG8gd29ybGQ=

// const buf2 = Buffer.alloc(23)
// buf2.write('68656c6c6f20776f726c64', 'hex')
// buf2.write('aGVsbG8gd29ybGQ=', 12, 'base64')
// console.log(buf2.write(' ', 11, 'utf8'))
// console.log(buf2)
// console.log(buf2.toString('utf8'))

// const buf = Buffer.alloc(25)

// buf.writeInt8(-100, 0)
// buf.writeUInt8(156, 2)

// console.log(buf)

// console.log(buf.toString('utf8'))

// const a = Buffer.from([72, 90, 94, 0x63, 0x6f, 0x73])
// console.log(a.toString())

// const a = Buffer.from('aboba')
// const b = a.slice(0, 3)
// console.log(a,b)
// b[0]++
// console.log(a,b)

const buf = Buffer.from('buffer')

for (const key of buf.keys()) {
  console.log(key)
}
const bufer = Buffer.alloc(20)

bufer.writeInt32BE(1234814)
bufer.writeInt8(14, 4)
console.log(bufer)

for (const key of bufer.values()) {
  console.log(key)
}
